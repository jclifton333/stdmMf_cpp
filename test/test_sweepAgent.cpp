#include <gtest/gtest.h>
#include <glog/logging.h>

#include <algorithm>

#include "random.hpp"
#include "network.hpp"
#include "networkRunFeatures.hpp"
#include "sweepAgentSlow.hpp"
#include "sweepAgent.hpp"
#include "utilities.hpp"

namespace stdmMf {

TEST(TestSweepAgentSlow, ApplyTrt) {
    // generate network
    NetworkInit init;
    init.set_dim_x(5);
    init.set_dim_y(4);
    init.set_wrap(false);
    init.set_type(NetworkInit_NetType_GRID);

    std::shared_ptr<Network> n = Network::gen_network(init);

    std::shared_ptr<NetworkRunFeatures> nrf(new NetworkRunFeatures(n, 1));

    // std::random_device rd;
    const uint32_t seed = 0; // crd();
    Rng rng;
    rng.set_seed(seed);

    // setup sweep agent
    std::vector<double> coef(nrf->num_features());
    std::for_each(coef.begin(), coef.end(),
            [&rng] (double & x) {
                x = rng.rnorm_01();
            });
    SweepAgentSlow sa(n, nrf, coef, 0);


    for (uint32_t reps = 0; reps < 50; ++reps) {
        // get random infection state
        boost::dynamic_bitset<> inf_bits(n->size());
        const uint32_t num_inf = rng.rint(0, n->size());
        const std::vector<int> inf_list = rng.sample_range(0, n->size(),
                num_inf);
        for (uint32_t i = 0; i < num_inf; ++i) {
            inf_bits.set(inf_list.at(i));
        }


        // get best by brute force
        double brute_best_val = std::numeric_limits<double>::lowest();
        std::string brute_bits;
        {
            std::vector<uint32_t> trt_list(n->size(), 0);
            std::fill(trt_list.begin(), trt_list.begin() + sa.num_trt(), 1);

            do {
                // get trt_bits
                boost::dynamic_bitset<> trt_bits(n->size());
                for (uint32_t i = 0; i < n->size(); ++i) {
                    if (trt_list.at(i) == 1) {
                        trt_bits.set(i);
                    }
                }

                ASSERT_EQ(trt_bits.count(), sa.num_trt());

                // calc features
                const std::vector<double> f = nrf->get_features(inf_bits,
                        trt_bits);

                const double val = dot_a_and_b(coef, f);

                // assume no ties since coef are random
                if (val > brute_best_val) {
                    brute_best_val = val;
                    boost::to_string(trt_bits, brute_bits);
                }
            } while(std::prev_permutation(trt_list.begin(), trt_list.end()));
        }


        // get best from SweepAgentSlow
        double sweep_agent_best_val = 0.0;
        std::string sweep_bits;
        {
            const boost::dynamic_bitset<> trt_bits = sa.apply_trt(inf_bits,
                    std::vector<BitsetPair>());
            boost::to_string(trt_bits, sweep_bits);

            const std::vector<double> f = nrf->get_features(inf_bits, trt_bits);
            sweep_agent_best_val = dot_a_and_b(coef, f);
        }


        EXPECT_EQ(sweep_agent_best_val, brute_best_val)
            << std::endl
            << "sweep: " << sweep_bits << std::endl
            << "brute: " << brute_bits << std::endl;
    }
}

TEST(TestSweepAgent, TestEquality) {
    // generate network
    NetworkInit init;
    init.set_dim_x(10);
    init.set_dim_y(10);
    init.set_wrap(false);
    init.set_type(NetworkInit_NetType_GRID);

    std::shared_ptr<Network> n = Network::gen_network(init);

    std::shared_ptr<Features> f_slow(new NetworkRunFeatures(n, 4));
    std::shared_ptr<Features> f(new NetworkRunFeatures(n, 4));

    std::shared_ptr<Rng> rng(new Rng);

    for (uint32_t i = 0; i < 2; ++i) {
        std::vector<double> coef(f->num_features(),0.);
        std::for_each(coef.begin(), coef.end(),
                [&rng](double & x) {
                    x = rng->rnorm_01();
                });

        SweepAgent sa(n, f, coef, 2);
        SweepAgentSlow sas(n, f_slow, coef, 2);

        for (uint32_t j = 0; j < 5; ++j) {
            // randomly infect 10 percent
            const std::vector<int> inf_bits_vec = rng->sample_range(0,
                    n->size(), n->size()*0.1);
            boost::dynamic_bitset<> inf_bits(n->size());
            for (uint32_t k = 0; k < inf_bits_vec.size(); ++k) {
                inf_bits.set(inf_bits_vec.at(k));
            }

            // apply trt with both agents
            const boost::dynamic_bitset<> trt_bits = sa.apply_trt(inf_bits);
            const boost::dynamic_bitset<> trt_bits_slow = sas.apply_trt(
                    inf_bits);

            CHECK_EQ(trt_bits, trt_bits_slow);
        }
    }
}


TEST(TestSweepAgentSlow, TestBug1) {
    // generate network
    NetworkInit init;
    init.set_dim_x(10);
    init.set_dim_y(10);
    init.set_wrap(false);
    init.set_type(NetworkInit_NetType_GRID);

    std::shared_ptr<Network> n = Network::gen_network(init);

    std::shared_ptr<Features> f(new NetworkRunFeatures(n, 2));

    // setup conditions
    std::mt19937 gen;
    std::stringstream ss;
    ss << "1499117434 2949980591 2242547484 1470907986 68004624 613504879 "
       << "2170701638 3606168244 1313189820 2904302179 3340054280 2800779156 "
       << "3718152353 1082918459 1748036786 3125556887 1246967947 2050301915 "
       << "3440863170 2306625137 2391836667 1253663658 2419038162 3499839328 "
       << "3576356820 3828856986 723946277 1516277410 1749873187 2585175776 "
       << "2103116091 3761404950 2177145536 2190050649 2604636580 1049507822 "
       << "3538272245 2566586914 3538170909 4282737256 3260797503 2387454175 "
       << "2226689230 2256270485 436199026 1447928333 1300475185 3910190296 "
       << "2621047601 2432253395 3548512997 3038311477 3870448599 4184179771 "
       << "331186464 1513235983 1123184249 1412176674 974731669 1184859182 "
       << "3903198916 1010728009 1157972564 1456817460 4280740152 3287444695 "
       << "3162962129 2065442163 702491398 2129714181 1271816637 1310830189 "
       << "1626731654 1866514111 1145033966 2096979273 2857723036 2877285051 "
       << "1233691756 3406459472 2679202709 2261680737 2760540573 3132376759 "
       << "2074456028 3178098775 1678464938 3178820511 305433718 1225231537 "
       << "3156384120 3587239912 3478639458 2028713297 4156933370 866469559 "
       << "3703313170 625989901 1353127228 729767191 4239080664 641370747 "
       << "1955789567 1184483474 3615076882 1341804132 4128348873 476722230 "
       << "3105112074 2941286171 1022165683 2123179945 3314940402 1416016978 "
       << "182868013 212411023 2656030053 3779055339 1701545199 3674791907 "
       << "1610475395 4164729361 3427598377 1307908931 3358502771 486424629 "
       << "3160463068 530473 1969914083 3170240630 2476207192 970601343 "
       << "3050844754 3669355176 1340421889 1617766323 383602626 1129117316 "
       << "918572908 3695476486 1764430370 2967235222 3067123020 3308359510 "
       << "886384482 1779812486 134534642 249966516 1332585561 3554068711 "
       << "2291677649 745254821 2206408749 3127595267 2427295058 2080674446 "
       << "3966791228 3103784816 3497882275 1573818670 3427455398 457267352 "
       << "2529982677 2344224288 3690569723 248871130 2179310377 865022852 "
       << "1702071740 4288128097 1599397573 3506259146 417400689 979397279 "
       << "2329289638 4250587448 2344846879 680016533 1695335972 1029810276 "
       << "539516489 308097557 3619920399 2136876981 3188293348 2584894221 "
       << "28295363 3838647908 2639611160 4292020015 732968695 400393115 "
       << "1281778179 4027605317 1571824415 2427335146 3951797079 4109264582 "
       << "2994313380 439622896 902291932 963577727 1534876665 3469900053 "
       << "582883584 3933453152 1367296016 3323503576 3479007798 3508689472 "
       << "3981387120 2284621917 644918556 3126057051 3371160597 360961626 "
       << "2318659802 2659611811 1109993553 976968874 2599208784 476384943 "
       << "2152559827 4228879964 3340725858 3377206995 611218954 3758666271 "
       << "204230618 2720785399 4240723682 250681258 3323652135 3522391030 "
       << "1679469787 1822904798 1634199872 2008317582 1454968079 3626508702 "
       << "3467404574 2237369830 1746454442 210635819 730534995 2970064151 "
       << "4032911749 2365458027 156048282 3086236733 3622099357 1881089091 "
       << "3160142011 2517013923 4259688426 1985910537 478356813 3841516698 "
       << "564566346 1245013975 562343064 147297885 2667097084 33053774 289997958 "
       << "4031215483 307664953 338764258 216795544 1176428186 1722385594 "
       << "4109337023 902037905 3282686150 866315897 1566946094 3436757989 "
       << "4073168121 3257551583 3729158933 1341787975 2230959320 3312211250 "
       << "1110585395 549424380 266278641 2661082464 918562329 1832478886 "
       << "309640646 985228208 1030556840 3713537458 294610547 3230155546 "
       << "342999365 1650341511 646766830 2190852369 4013264374 2999309863 "
       << "3512212270 4199392792 559679946 3722272229 1407612141 1792120543 "
       << "4122566255 2614747898 2411819608 461168343 3702772741 1220049823 "
       << "3578175138 3852491473 749653032 3297521103 2283357169 4012942068 "
       << "1761213419 4113654008 3548247038 2450573353 913028441 941292270 "
       << "1062104348 3559036436 3098831818 2441286605 1767279766 665722183 "
       << "667938201 2115822312 632855671 573491393 1443199826 1385074753 "
       << "3283060992 2311971637 2752946404 1812020773 3552985610 1175234724 "
       << "3066736347 3207299299 494815379 3080299380 1328809279 2857280599 "
       << "3620070973 4104567805 233766183 1510754877 2088578672 3466416800 "
       << "1218866416 2910921178 4088694641 767425533 4213797255 4108502172 "
       << "3545928547 798512684 238469855 2177829079 161989331 3365800849 "
       << "2832396926 2288844520 365958019 1048129741 3910765196 578163052 "
       << "498293036 996355356 2467376228 1167452999 1421147442 1470070868 "
       << "2232229242 971713252 4601830 3060810946 3981863019 10533660 645408574 "
       << "951764939 1081827337 856091495 3256327929 3943141609 608907788 "
       << "375942741 303213809 129581283 2316412238 4025818291 2320185240 "
       << "58709957 1130142811 3083180922 1728575124 1005679445 4010033131 "
       << "3463261972 1599589218 2944201358 998218261 1337347381 448276061 "
       << "2250331771 418675356 697905216 679894468 584704117 514529685 "
       << "2690138981 3418589197 1509583568 192934325 2967937654 3043082650 "
       << "4265822072 4005601311 1591945647 150467832 2721968946 3023830288 "
       << "714242249 2873512783 3745297318 1819521769 529316705 3521879874 "
       << "17301388 3215821847 2853052802 3919146899 4165616209 2455818705 "
       << "1240188609 3927742424 2903203100 1244137294 741844902 458324948 "
       << "1511914231 3125286162 3079518156 642386738 2974377153 1136715589 "
       << "2578741635 3476966223 3197973312 42917716 227989534 3138586301 "
       << "3860599407 805061872 3045580455 3437871910 3649496171 3383237696 "
       << "4198706430 3208275784 1159529867 812992888 1663743968 3304323191 "
       << "3579556116 3065695838 1533392246 1728991672 2410503844 51457241 "
       << "456639707 1474621262 2047196546 765440796 3836850492 3519898591 "
       << "3238633263 4104772312 2751030611 2811588637 543572636 1010895876 "
       << "2500894419 969395948 870953104 1221107222 2330006170 2409103364 "
       << "67838397 1059660678 981997131 157339796 4122881705 1275571984 "
       << "1376739609 2654593847 4245999311 3218382298 2865701791 3426791069 "
       << "2181612501 1978427330 1891092703 1477957498 477396699 2899811827 "
       << "3561541108 38071220 3004798622 3748740755 2387018968 3379410087 "
       << "3500770886 4290845522 1306421722 4061617178 3719031563 3544895976 "
       << "775448154 1295600548 2308544365 460297677 271736902 1984777327 "
       << "367790966 2800519412 2614870765 2209236836 621299190 2309489514 "
       << "3281711777 1666440249 1268622496 1002604100 3869900053 4177509506 "
       << "1549221268 408669572 74305461 2387017947 4069382846 2662554313 "
       << "2236794110 2400926529 1454900388 2553366914 4122621433 153680433 "
       << "4089017425 309618270 720140943 1580185479 1482824076 2492840294 "
       << "300423339 1389751103 1596279966 3486917639 1417455769 213467785 "
       << "1202911685 2216271923 3978399634 3875432211 3552842638 3377523836 "
       << "3009711916 2514548139 1473040763 3692679012 347386951 3051729582 "
       << "1132030033 388965211 2444692342 2901459919 1019332451 2485660381 "
       << "1507720730 3694695280 3832666300 1442556581 3318272968 2523446528 "
       << "2080451171 13087074 310081129 3393457124 217258772 921897669 "
       << "3442463899 3303171220 952234306 1562562305 1232541219 3092977850 "
       << "692610990 552527312 2576547843 2353120775 2677220022 3876270818 "
       << "3246249731 3269986504 3247423946 1068893543 3140350604 4276750153 "
       << "729661030 121118073 2284780802 1266571381 589714818 23256702 "
       << "3758946125 1229567432 4162027047 3277342478 98";
    ss >> gen;

    boost::dynamic_bitset<> trt_bits(n->size());
    std::vector<uint32_t> trt_bits_vec =
        {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0};
    CHECK_EQ(trt_bits_vec.size(), n->size());
    for (uint32_t i = 0; i < n->size(); ++i) {
        if (trt_bits_vec.at(i) == 1) {
            trt_bits.set(i);
        } else {
            trt_bits.reset(i);
        }
    }

    double best_val = 2320;

    std::set<uint32_t> not_trt =
        {0, 1, 2, 3, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 25,
         26, 27, 28, 29, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
         45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
         63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 74, 75, 76, 77, 78, 79, 80, 81,
         82, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99};

    std::set<uint32_t> has_trt = {4, 5, 6, 7, 8, 9, 19, 33, 73, 83};

    boost::dynamic_bitset<> inf_bits(n->size());
    std::vector<uint32_t> inf_bits_vec =
        {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0};
    CHECK_EQ(inf_bits_vec.size(), n->size());
    for (uint32_t i = 0; i < n->size(); ++i) {
        if (inf_bits_vec.at(i) == 1) {
            inf_bits.set(i);
        } else {
            inf_bits.reset(i);
        }
    }

    std::vector<double> coef =
        {10, 10, 10, 10, 10, -10, -10, -10, -10, -10, 10, -10, -10, 10, -10, 10,
         -10, 10, -10};


    SweepAgentSlow sa(n, f, coef, 2);

    sa.sweep_treatments(trt_bits, best_val, not_trt, has_trt, inf_bits);
}



} // namespace stdmMf



int main(int argc, char **argv)
{
    ::google::InitGoogleLogging(argv[0]);
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
